---
title: Working With GraphQL
index: 2
description: An overview of the various ways Houdini applications can leverage GraphQL documents.
---

<script>
    import { Transformation, DeepDive, Highlight, Warning } from '~/components'

    const storeSource = `
    # Operation defined in a .gql or .graphql file
    query ViewerProfile {
        viewer {
            firstName
        }
    }`

    const storeTypeDef = `
// Generated Store
type ViewerProfileStore = {
    subscribe: Readable<ViewerProfile>
    fetch(...): Promise<void>
}`
</script>

# Working with GraphQL

Everyone's has different needs from their GraphQL client. That means that in order to provide a high quality
developer experience, Houdini must support a few different APIs that overlap. While this is great for the
community as a whole, it creates a challenge for newcomers since there isn't a clear path for how to
structure their applications.

The goal of this guide is to walk you through the various ways Houdini lets you work with GraphQL so you can hopefully find something that maps
onto the way you think. If nothing's clicking, please reach out on Discord or GitHub. I'm sure we can figure _something_ out. Also, don't worry:
we do have an official recommendation at the end for a structure that we think works well.

Let's start by going over the core abstraction powering Houdini's data fetching: Document Stores.

## Document Stores

When Houdini detects a graphql document in your project, it generates a [Svelte store](https://svelte.dev/tutorial/writable-stores) that you
can use to interact with your data. Every document type (query, mutation, subscription) generates a different kind of store with different methods.

<Transformation>
    <Highlight language="graphql" code={storeSource} slot="from"/>
    <Highlight language="typescript" code={storeTypeDef} slot="to" />
</Transformation>

These stores are your primary tools in a Houdini application. So how how do you define your documents so Houdini can do its magic?

## Defining Documents

There are two different ways you can define graphql documents in a Houdini application:

- **External documents**: you write your graphql documents in dedicated graphql files (`.gql` or
  `.graphql` for example) and interact with stores that you import from `$houdini`.
- **Inline documents**: you define your graphql documents inside your `.svelte`, `.ts` or `.js` files and
  interact with stores that are provided by the `graphql` tag.

The following examples all show query documents but everything holds true for all document types (queries, mutations, fragments, and subscriptions).

### External Documents

External documents are pretty self explanatory: define your graphql documents a file (one definition per file) and then import your
store from `$houdini` as `GQL_DocumentName`:

```graphql
# src/lib/queries/MyAwesomeQuery.gql

query MyAwesomeQuery {
	viewer {
		isAwesome
	}
}
```

```javascript
// src/routes/myRoute/+page.js
import { GQL_MyAwesomeQuery } from '$houdini'
```

Note the prefix `GQL_` is to enable easy autocompletion in your editor - give it a try!

<DeepDive title="Importing Document Stores">

All document stores can be imported in three different ways. You can either import the default export of the path which will provide an
instance of the store you can work with easily:

```javascript
import store from '$houdini/stores/MyQuery'
```

You can import the same instance from the root of the runtime with `GQL_` prepended to the store's name.

```javascript
import { GQL_MyQuery } from '$houdini'
```

Or, you can import a factory from the module that will let you instantiate multiple copies of the same store if you need to:

```javascript
import { MyQueryStore } from '$houdini/stores/MyQuery'

const store = MyQueryStore()
```

</DeepDive>

### Inline Documents

Another option is to define your document directly inside of your source code (ie, in a `.svelte`, `.js`, or `.ts` file). To
do that, import `graphql` from `$houdini` and wrap your query inside of the template tag:

```svelte
<!-- src/routes/myRoute/+page.svelte -->
<script>
	import { graphql } from '$houdini'

	const store = graphql`
		query ViewerSettings {
			viewer {
				isAwesome
			}
		}
	`
</script>
```

```javascript
// src/routes/myRoute/+page.js

import { graphql } from '$houdini'

const store = graphql`
	query MyAwesomeQuery {
		viewer {
			isAwesome
		}
	}
`
```

### More Information

For more information on each store type, please visit the [api docs](/api/welcome).

## Loading Data

Once you have your store, the next step is to start using it. Explanations for fragments, mutations, and subscriptions,
are better left for the <a href="/api/welcome/" target="_blank" rel="noreferrer">api docs</a> but
queries have some unique requirements that are worth covering in detail. In fact, the rest of this section
is going to focus exclusively on loading data into SvelteKit routes.

Usually, your route's `.svelte` files will receive their stores as props. This often looks something like:

```svelte
<!-- src/routes/myProfile/+page.svelte -->
<script>
	export let data

	$: ({ UserProfile } = data)
</script>

{$UserProfile.data.viewer.firstName}
```

Of course, you could have also defined an inline store, but most of the time, you'll want to SSR your views which means we have to define
a `load` function in `+page.js`. This leads us to the next question: do you want Houdini to generate the load function for you?

### Manual Loads

If you are the kind of person who doesn't like hidden details, you are totally free to define your own load function as long as you call
the store's `fetch` method. In order to streamline this, Houdini provides a function for each of your stores that you can use to render
your route on the server. These functions take the same parameters as fetch:

```typescript
//  src/routes/myProfile/+page.js

import { load_MyQuery } from '$houdini'

export async function load(event) {
	return {
		...(await load_MyQuery({ event }))
	}
}
```

If even _that_ is too much magic for you, rest assured all it's doing is instantiating a store and calling `.fetch`. You can check out the definition yourself
inside of the `$houdini/stores/MyStore.js`. If you still want to do something custom, you are free to structure things however you want
just make sure that you instantiate stores inside of `load` and pass them to your route's `.svelte` file as props.

<Warning>

Do not use global stores (ie, `GQL_MyQuery`) in `load` functions unless you have a very good reason. Global stores are not safe for SSR because they get mutated
by multiple users at the same time. By instantiating a new store on every load, you automatically support complex flows like prefetching and concurrent requests
without any hassle.

Also, be careful when loading multiple stores in a single load. You want to make sure that you aren't blocking one request while you wait for another. For
help in this situation, check out the loadAll function. It's described inside the Deep Dive, <a href="/api/query/store#sveltekit" target="_blank" rel="noreferrer">here</a>.

</Warning>

### Automatic Loads

On the other hand, maybe you are the kind of person who gets really tired of typing the same code over and over. For those people, Houdini's vite plugin offers some powerful
features that dramatically reduce the amount of boilerplate that you are responsible for.

You can tell houdini to generate a load for you by exporting a `houdini_load` value from `+page.js` that contains one or more query stores that you want to use in your route:

```javascript
//  src/routes/myProfile/+page.js
import { GQL_ProjectList, graphql } from '$houdini'

const userInfo = graphql`
	query UserInfo {
		viewer {
			firstName
		}
	}
`

export const houdini_load = [GQL_ProjectList, userInfo]
```

With that in place, your route will be passed two props: `ProjectList` and `UserInfo`:

```svelte
<!-- src/routes/myProfile/+page.svelte -->
<script>
	export let data

	$: ({ ProjectList, UserInfo } = data)

	$: { firstName } = $UserInfo.data.viewer
	$: { length } = $ProjectList.data.projects
</script>

{firstName} can see {length} projects
```

Keep in mind that `houdini_load` can also take a single query, which allows for an interesting approach:

```javascript
// src/routes/myProfile/+page.js

import { graphql } from '$houdini'

export const houdini_load = graphql`
	query UserInfo {
		viewer {
			firstName
		}
	}
`
```

This approach works nicely when you have lots of different variables and hooks for a particular query since it allows all of that logic to be co-located:

```javascript
// src/routes/myProfile/+page.js

import { graphql } from '$houdini'

export const houdini_load = graphql`
	query UserInfo($id: ID!) {
		user(id: $id) {
			firstName
		}
	}
`

export function UserInfoVariables({ params }) {
	return {
		id: params.id
	}
}
```

For more information on working with generated loads (ie, how to pass variables, perform logic before or after the actual fetch, etc), check out the [Inline Query docs](/api/query/inline).
It's fundamentally the same API even if those examples are for a slightly different situation than what we've seen so far.

### Inline Queries

Another way to get a generate load for your route queries, is to define your query inside of your `+page.svelte` wrapped inside of a `query` function:

```svelte
<!-- src/routes/myProfile/+page.svelte -->
<script>
	import { graphql, query } from '$houdini'

	const { data } = query(graphql`
		query UserInfo {
			viewer {
				firstName
			}
		}
	`)
</script>

{$data.viewer.firstName}
```

This approach behaves exactly the same as what we saw before. Benefit of this approach is that we didn't have to
modify `+page.js` just because we added a query to our route. However, the moment we want to do anything extra (variables, hooks, etc) those
will have to go inside of `+page.js` so this approach can feel a little scattered at times.

### Page Queries

The final approach for loading your data that we need to cover is by defining a page query. A page query is a query defined inside of a `+page.gql`
file inside of your route directory. This file behaves like the rest of SvelteKit's `+page` files and automatically configures your route to load the
provided query. For example, with the following query defined:

```graphql
# src/routes/myProfile/+page.gql

query UserInfo {
	viewer {
		firstName
	}
}
```

You can now define a `+page.svelte` file that looks like the following and your route will be SSR'd without any extra configuration:

```svelte
<!-- src/routes/myProfile/+page.svelte -->
<script>
	export let data

	$: ({ UserInfo } = data)
</script>

{$UserInfo.data.viewer.firstName}
```

Keep in mind, if you want to define variable functions or hooks, those will go in `+page.js`.

## Conclusion

I know, that was a lot.

Hopefully something along the way clicked for you but if you are still struggling to figure out how you want to structure your apps, here's our
recommendation to start:

- route queries should go in `+page.gql` with variable definitions and hooks inside of `+page.ts` (remember, there's no need to define `houdini_load` if you're using `+page.gql`)
- fragments should be defined inline, inside of your `.svelte` components using the `fragment` function
- mutations and subscriptions are safe to use globally (assuming you don't render the value) so we usually grab them as `GQL_` imports from `$houdini`
