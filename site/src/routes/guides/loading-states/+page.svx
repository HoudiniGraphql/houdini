---
title: Loading States
description: An overview of the tools that houdini provides to help construct loading states for your application.
---

<script>
    import LoadingPokedex from '~/components/pokedex/LoadingState.svelte'
</script>

# Loading States

At some point, your users are going to be waiting for data to load from the server. This could be because they
don't live in a place with state-of-the-art internet service or maybe they just stepped into a tunnel. Regardless,
you are going to want to show them _something_ while your request loads.

This guide will go over all of the tools that Houdini provides to help you build interfaces for your loading states.

## A Concrete Example

Before we get too far, let's look at a concrete example so we can have a goal in mind. For this guide,
we're going to be building a loading screen for the Pok√©dex that we constructed in the [Getting Started](/intro) guide:

<p>
    <LoadingPokedex />
</p>

For the sake of this guide, you can imagine that the Pokedex is built using the following route:

```graphql:title=src/routes/[[id]]/+page.qgl
query SpeciesInfo($id: Int = 1) {
    species(id: $id) {
        name
        description
        evolutionChain {
            edges {
                node {
                    name
                    ...Sprite
                }
            }
        }

        ...Sprite
        ...EvolutionChain
        ...NavButtons
    }
}
```

```svelte:title=src/routes/[[id]]/+page.svelte&typescriptToggle=true
<script lang="ts">
    import type { PageData } from './$houdini'
    // prettier-ignore
    import {
        Container,
        Panel,
        Sprite,
        Display,
        MoveList,
        NavButtons,
        Number,
    } from '~/components'

    export let data: PageData

    let { SpeciesInfo } = data
    $: ({ SpeciesInfo } = data)

    $: species = $SpeciesInfo.data.species
</script>

<Container>
    <Panel slot="left">
        <Display>
            {species.name}
        </Display>
        <Sprite {species} />
        <Display>
            {species.description}
        </Display>
    </Panel>
    <Panel slot="right">
        <div class="evolution-chain">
            {#each species.evolutionChain.edges as { node }, i }
                <div class="evolution-form">
                    <Number value={i + 1} />
                    <Sprite style="height: 96px;" species={node} />
                    <Display>
                        {node.name}
                    </Display>
                </div>
            {/each}
        </div>
        <MoveList {species} />
        <NavButtons {species} />
    </Panel>
</Container>
```

Just in case it's not clear: the `evolutionChain` list corresponds to the 3 columns
in the top right of the loading screen above. If it helps, you can look at a deployed
version of the application [here](http://houdini-intro.pages.dev).

## The Simplest Solution

If you followed along in the [Getting Started Guide](/intro) then you know that this example
has a serious issue: if we click on the `next` button then our application will crash. This is
because `data` is `null` when the query is loading a new value which causes
`$SpeciesInfo.data.species` to explode. The easiest way to protect against
this is to check the `fetching` value of the store and render your loading state.

Sorry in advanced about the length of the following example but it highlights the primary points
we're trying to illustrate: this approach duplicates a _lot_ of logic and structure.

```svelte:title=src/routes/[[id]]/+page.svelte&typescriptToggle=true
<script lang="ts">
    import type { PageData } from './$houdini'
    // prettier-ignore
    import {
        Container,
        Panel,
        Sprite,
        Display,
        MoveList,
        UpDownButtons,
        Button,
        Number,
    } from '~/components'

    export let data: PageData

    let { SpeciesInfo } = data
    $: ({ SpeciesInfo } = data)

    $: species = $SpeciesInfo.data.species
</script>

{#if $SpeciesInfo.fetching}
    <Container>
        <Panel slot="left">
            <Display height={30} loading />
            <Sprite style="flex-grow:1" loading />
            <Display height={120} loading/>
        </Panel>
        <Panel slot="right">
            <div class="evolution-chain">
                {#each Array.from({length: 3}) as _, i }
                    <div class="evolution-form">
                        <Number value={i + 1} />
                        <Sprite height={96} loading />
                        <Display height={30} loading />
                    </div>
                {/each}
            </div>
            <div class="row">
                <Display height={400} loading />
                <UpDownButtons disabled />
            </div>
            <div class="row">
                <Button disabled>Previous</Button>
                <Button disabled>Next</Button>
            </div>
        </Panel>
    </Container>
{:else}
    <Container>
        <Panel slot="left">
            <Display>
                {species.name}
            </Display>
            <Sprite {species} />
            <Display>
                {species.description}
            </Display>
        </Panel>
        <Panel slot="right">
            <div class="evolution-chain">
                {#each species.evolutionChain.edges as { node }, i }
                    <div class="evolution-form">
                        <Number value={number + 1} />
                        <Sprite style="height: 96px;" species={node} />
                        <Display>
                            {node.name}
                        </Display>
                    </div>
                {/each}
            </div>
            <MoveList {species} />
            <NavButtons {species} />
        </Panel>
    </Container>
{/if}
```

There are 2 major problems with this:

1. We basically have to build our layout twice. Even if we relied heavily on the `?` operator or sprinkled a bunch of `#if $data` everywhere, we _must_ duplicate the logic for the evolution chain since we don't have a list to iterate over
   to render the boxes.
1. We had to break the abstraction created by the `MoveList` and `NavButtons` components since we needed to
   duplicate their structure here (something this component is supposed to know nothing about).

Bottom Line? No matter how we approach it, building a loading state based the `fetching` value is pretty annoying.
But don't worry - Houdini solves both of these problems with a single directive: `@loading`.

## Loading State Structure

Let's look at how we can use it to address the first point by using the `@loading` directive.
