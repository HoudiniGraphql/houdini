---
title: Client Plugins
description: The API reference for HoudiniClient plugins
---

<script>
    import { Warning, PluginWorkflow } from '~/components'
</script>

# Client Plugins

Client plugins allow you to customize the runtime behavior of your application's documents.
They can do things like integrate with a logging service, adding retry logic,
or even add support for entirely new network capabilities like
[Live Queries](https://the-guild.dev/blog/subscriptions-and-live-queries-real-time-with-graphql).

## Overview

In Houdini, every document is your app is backed by an observable value we call a "Document Store".
The store has 2 main concerns: holding onto the latest value of the document and sending new
queries to update its state (usually with new variables). Client plugins let you modify this
to fit your needs by hooking into 4 different phases of the request pipeline:

- `start` happens at the beginning of a request (or setup cycle) and contains logic that must happen for every request
- `network` performs the actual network request
- `afterNetwork` for logic after the network request but before the cache processes it
- `end` happens at the end of the request regardless of the data’s source

For some documents, the `network` and `afterNetwork` steps might be short circuited with cached values
if the policy allows it. You can think of the cache as a gatekeeper that decides if a request can be resolved
before beginning the network phases.

<PluginWorkflow />

While preparing the request, plugins are iterated over in the order they are passed to the client. Once a result
has been provided, its value is sent in reverse order through the list of plugins we've visited who can
modify the response.

## Your First Client Plugin

Let's start off simple and create a plugin to log something every time we send a query. If you don't have
a project to test in, you can always use [`final` branch](https://github.com/HoudiniGraphql/intro/tree/final) branch
of the PokeDex we made in the [Getting Started guide](/intro/welcome).

Once you have a project, we can define an empty plugin and pass it to your client:

```typescript:title=src/client.ts&typescriptToggle=true
import type { ClientPlugin } from '$houdini'

const sayHello: ClientPlugin = () => {
    return {}
}

export default new HoudiniClient({
    url: "...",
    plugins: [
        sayHello
    ]
})
```

Fundamentally a plugin is just a function that returns an object. That object can have a few different keys
to hook into different phases of the request. For our purposes, we just need to define an `start` function that
will run at the beginning of every request:

```typescript:title=src/client.ts&typescriptToggle=true
import type { ClientPlugin } from '$houdini'

const sayHello: ClientPlugin = () => {
    return {
        start(ctx, { next }) {
            // say hello
            console.log("Hello world!")

            // move onto the next step in the pipeline
            next(ctx)
        }
    }
}
```

And that's it! If you click around your app now, you should see our message logged every time a request is made.

<Warning title="Your plugin must call `next` or `resolve`">

While most of this example is self-explanatory, it's important to highlight that we had to call `next(ctx)`
in our plugin to indicate we were done. It's important to remember that these phases are asynchronous by nature.
If we never call `next` (or `resolve`) the pipeline would never terminate.

</Warning>

## Your Second Plugin

Now that you know what a plugin looks like, let's take it up a notch and create another one. This time, we're
going to create a plugin that retries a query if we encountered an error in the result.

It starts off looking very similar to the first example except this time we'll hook into the `end` step:

```typescript:title=src/client.ts&typescriptToggle=true
import type { ClientPlugin } from '$houdini'

const retry: ClientPlugin = () => {
    return {
        end(ctx, { resolve }) {
            // move onto the next step in the pipeline
            resolve(ctx)
        }
    }
}
```

One important difference between `resolve` and `next` is the direction we are going. As we saw before, `next` is meant to push
the pipeline forward and send a request. `resolve` does the opposite and pushes an answer back to the caller/store. This means
that `end` and `afterNetwork` need to `resolve` at some point in order to finish the request. While this does sound kind of
complicated, having this distinction allows us to replay the request if we run into an error relatively easily:

```typescript:title=src/client.ts&typescriptToggle=true
import type { ClientPlugin } from '$houdini'

const retry: ClientPlugin = () => {
    return {
        end(ctx, { value, next, resolve }) {
            // if we ran into an error, start another request
            if (value.errors && value.errors.length > 0) {
                next(ctx)
                return
            }

            // there is no error so we can use the result
            resolve(ctx)
        }
    }
}
```

Keep in mind you would probably want to add more to this example in production so that you wouldn't be stuck in an loop that constantly errors
but hopefully you can piece together how you would do that.

## Plugins Are Data Sources

The store might receive multiple updates for a given set of inputs. For example, subscriptions and live queries
both push multiple documents into the cache and need to update the store value. Each payload should be pushed all
the way through the chain using the same function. If the original request hasn’t been resolved when a payload
reaches the end, the promise will resolve with that first value.
