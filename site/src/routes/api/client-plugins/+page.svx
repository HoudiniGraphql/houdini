---
title: Client Plugins
description: The API reference for HoudiniClient plugins
---

<script>
    import PluginWorkflow from './Workflow.svelte'
    import AuthoringPluginsDive from './Authoring.svx'
    import { Warning, DeepDive, Emoji, Zoomable } from '~/components'
</script>

# Client Plugins

Client plugins allow you to customize the runtime behavior of your application's documents.
They can do things like integrate with a logging service, adding retry logic,
or even add support for entirely new network capabilities like
[Live Queries](https://the-guild.dev/blog/subscriptions-and-live-queries-real-time-with-graphql).

## Overview

In Houdini, every document in your app is backed by an observable value we call a "Document Store".
The store has 2 main concerns: holding onto the latest value of the document and sending new
queries to update its state (usually with new variables). Client plugins let you modify this structure
to fit your needs by hooking into 4 different phases of the request pipeline:

- `start` happens at the beginning of a request (or setup cycle) and contains logic that must happen for every request
- `network` performs the actual network request
- `afterNetwork` for logic after the network request but before the cache processes it
- `end` happens at the end of the request regardless of the dataâ€™s source

For some documents, the `network` and `afterNetwork` steps might be short circuited with cached values
if the policy allows it. You can think of the cache as a gatekeeper that decides if a request can be resolved
before beginning the network phases.

<Zoomable>
    <PluginWorkflow />
</Zoomable>

While preparing the request, plugins are iterated over in the order they are passed to the client. Once a result
has been provided, its value is sent in reverse order through the list of plugins we've visited who can
modify the response. For more information on this, please read the section on [Enter vs Exit hooks](#enter-vs-exit-hooks).

## Create Your First Plugin

<AuthoringPluginsDive />

## Enter vs Exit hooks

It's important to keep in mind the direction that information is flowing in a given step.
As mentioned before, the request pipeline is broken up into 4 distinct phases. `start` and `network`
are known as "enter hooks" whereas `afterNetwork` and `end` are known as "exit hooks".

### Enter Hook

In an enter hook, information flows forward, to the next plugin in the list:

```typescript:title=src/client.ts&typescriptToggle=true
import type { ClientPlugin } from '$houdini'

const sayHello: ClientPlugin = () => {
    return {
        start(ctx, { next }) {
            // say hello
            console.log("Hello world!")

            // move onto the next step in the pipeline
            next(ctx)
        }
    }
}
```

One enter hook in a list _must_ use the `resolve` function to provide a value
for the store. By default, `HoudiniClient` includes a fetch plugin that always
resolves the pipeline with a value. Here is a simplified version as an example:

```typescript:title=src/client.ts&typescriptToggle=true
import type { ClientPlugin } from '$houdini'

const simpleFetchPlugin: ClientPlugin = () => {
    return {
        async network(ctx, { resolve, next }) {
            const result = await fetch('...', {
                body: JSON.strinify({ query: ctx.artifact.raw })
            })

            // in reality we need to pass more here
            // see Type Defintions for more information
            resolve(ctx, {
                data: result.data
            })
        }
    }
}
```

There are a few things to keep in mind when defining Enter hooks:

- An enter hook can call `next` or `resolve` in any combination
  you want as long as at least one of them is always called. If you do
  not call one of them, your pipeline will hang indefinitely.
- When calling both `resolve` and `next` in the same hook, make
  sure to call `resolve` before `next` when possible so you can
  resolve the request as quickly as possible
- When calling `resolve` you have to pass a full `QueryResult`
  (see [Type Definitions](#type-definitions) below)

### Exit hooks

In an exit hook, we are returning a value from our request pipeline. This
means we use the `resolve` function to proceed through the pipeline as normal.
Apart from that, the biggest difference between an exit hook and
an enter hook is that an exit hook has a value that it can process:

```typescript:title=src/client.ts&typescriptToggle=true
import type { ClientPlugin } from '$houdini'

const logErrors: ClientPlugin = () => {
    return {
        end(ctx, { value, resolve }) {
            if (value.errors && value.errors.length > 0) {
                console.warn('encountered errors:', value.errors)
            }

            resolve(ctx)
        }
    }
}
```

An exit hook can also call `resolve` and `next` in the same function. However,
an exit hook needs to call `resolve` under some circumstances. If an exit hook never calls `resolve`,
the pipeline will hang forever <Emoji name="fear" height={20} fallback="ðŸ˜¨" style="margin-bottom: -3px" />

In Summary,

- You do not have to pass a value when calling `resolve`. The last known value will be used automatically. You are
  also free to modify the value.
- Make sure your exit hook resolves under some condition

## Stateful Plugins

Plugins can contain state across multiple requests as well as phases:

### State within a single request (multiple phases)

If you want to track state between various phases, you can put any values you want inside of `ctx.stuff`:

```typescript:title=src/client.ts&typescriptToggle=true
import type { ClientPlugin } from '$houdini'

const timer: ClientPlugin = () => {
    return {
        start(ctx, { next }) {
            // add the start time to the context's stuff
            ctx.stuff = {
                ...ctx.stuff,
                startTime: new Date(),
            }

            // move onto the next plugin
            next(ctx)
        },
        end(ctx, { resolve }) {
            // compute the difference in time between the
            // date we created on `start` and now
            const diff = Math.abs(new Date() - ctx.stuff.startTime)
            // print the result
            console.log(`This request took ${diff}ms`)

            // we're done
            resolve(ctx)
        }
    }
}
```

### State across network requests

If you're plugin needs to track some statment for multiple network requests, you can
instantiate the state before you return your plugin. Houdini will make sure that your
function is called only once when the store is created:

```typescript:title=src/client.ts&typescriptToggle=true
import type { ClientPlugin } from '$houdini'

const logErrors: ClientPlugin = () => {
    let lastVariables = {}

    return {
        start(ctx, { next, resolve, value }) {
            // add the last variables we used to the current request
            ctx.variables = {
                ...lastVariables,
                ...ctx.variables,
            }

            // track the last variables we used
            lastVariables = ctx.variables

            // move onto the next plugin
            next(ctx)
        }
    }
}
```

## Multiple Values

The store might receive multiple updates for a given set of inputs. For example, subscriptions and live queries
both push multiple documents into the cache and need to update the store value. Each payload is pushed all
the way through the chain using the same `resolve` function. If the original request hasnâ€™t been resolved when a payload
reaches the end, the promise will resolve with that first value so you are free to use `resolve` inside of event
listeners to return multiple values.

## Utilities

`next` and `resolve` are just two examples of functions passed as the second argument
to your hooks. For a full summary, please refer to the the `ClientPluginEnterHandlers` and
`ClientPluginExitHandlers` in the [Type Definitions section below](#type-definitions).

## Changing Values

For the most part, you are free to update any values in the context object passed to your hook. That being said,
if you modify a value please assign the value directly:

```typescript:title=src/client.ts&typescriptToggle=true
import type { ClientPlugin } from '$houdini'

const logErrors: ClientPlugin = () => {
    return {
        start(ctx, { next }) {

            ctx.variables = {
                ...ctx.variables,
                something: 'else',
            }

            next(ctx)
        }
    }
}
```

## Type Definitions

The best source of truth for the type definitions are exported from your `$houdini`
package. They've been summarized below for reference but this copy may be out of date.
If you find a discrepancy, please let us know on GitHub.

```typescript
type ClientPlugin = () => {
	start?: ClientPluginEnterPhase
	network?: ClientPluginEnterPhase
	afterNetwork?: ClientPluginExitPhase
	end?: ClientPluginExitPhase
	cleanup?(ctx: ClientPluginContext): void | Promise<void>
	throw?(ctx: ClientPluginContext, args: ClientPluginErrorHandlers): void | Promise<void>
}

type ClientPluginPhase<Handlers> = (
	ctx: ClientPluginContext,
	handlers: Handlers
) => void | Promise<void>

type ClientPluginEnterPhase = ClientPluginPhase<ClientPluginEnterHandlers>
type ClientPluginExitPhase = ClientPluginPhase<ClientPluginExitHandlers>

type ClientPluginEnterHandlers = {
	/* The initial value of the query */
	initialValue: QueryResult
	/** A reference to the houdini client */
	client: HoudiniClient
	/** Move onto the next step using the provided context.  */
	next(ctx: ClientPluginContext): void
	/** Terminate the current chain  */
	resolve(ctx: ClientPluginContext, data: QueryResult): void

	/** Update the stores state without resolving the promise */
	updateState(updater: (old: QueryResult) => QueryResult): void

	/** Return true if the variables have changed */
	variablesChanged: (ctx: ClientPluginContext) => boolean
	/** Returns the marshaled variables for the operation */
	marshalVariables: (ctx: ClientPluginContext) => Record<string, any>
}

/**
 * Exit handlers are the same as enter handles but don't need to
 * resolve with a specific value
 */
type ClientPluginExitHandlers = {
	/* The response value we're exiting with */
	value: QueryResult

	/* The initial value of the query */
	initialValue: QueryResult
	/** A reference to the houdini client */
	client: HoudiniClient
	/** Move onto the next step using the provided context.  */
	next(ctx: ClientPluginContext): void
	/** Terminate the current chain  */
	resolve: (ctx: ClientPluginContext, data?: QueryResult) => void

	/** Update the stores state without resolving the promise */
	updateState(updater: (old: QueryResult) => QueryResult): void

	/** Return true if the variables have changed */
	variablesChanged: (ctx: ClientPluginContext) => boolean
	/** Returns the marshaled variables for the operation */
	marshalVariables: (ctx: ClientPluginContext) => Record<string, any>
}

type ClientPluginContext = {
	config: ConfigFile
	artifact: DocumentArtifact
	policy?: CachePolicy
	fetch?: Fetch
	variables?: Record<string, any>
	metadata?: App.Metadata | null
	session?: App.Session | null
	fetchParams?: RequestInit
	cacheParams?: {
		layer?: Layer
		notifySubscribers?: SubscriptionSpec[]
		forceNotify?: boolean
		disableWrite?: boolean
		disableRead?: boolean
		applyUpdates?: boolean
	}
	stuff: Record<string, any>
}

type QueryResult = {
	data: GraphQLObject | null
	errors: { message: string }[] | null
	fetching: boolean
	partial: boolean
	source: DataSource | null
	variables: _Input | null
}
```
