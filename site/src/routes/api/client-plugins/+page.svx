---
title: Client Plugins
description: The API reference for HoudiniClient plugins
---

<script>
    import { PluginWorkflow } from '~/components'
    import AuthoringPluginsDive from './Authoring.svx'
</script>

# Client Plugins

Client plugins allow you to customize the runtime behavior of your application's documents.
They can do things like integrate with a logging service, adding retry logic,
or even add support for entirely new network capabilities like
[Live Queries](https://the-guild.dev/blog/subscriptions-and-live-queries-real-time-with-graphql).

## Overview

In Houdini, every document is your app is backed by an observable value we call a "Document Store".
The store has 2 main concerns: holding onto the latest value of the document and sending new
queries to update its state (usually with new variables). Client plugins let you modify this
to fit your needs by hooking into 4 different phases of the request pipeline:

- `start` happens at the beginning of a request (or setup cycle) and contains logic that must happen for every request
- `network` performs the actual network request
- `afterNetwork` for logic after the network request but before the cache processes it
- `end` happens at the end of the request regardless of the dataâ€™s source

For some documents, the `network` and `afterNetwork` steps might be short circuited with cached values
if the policy allows it. You can think of the cache as a gatekeeper that decides if a request can be resolved
before beginning the network phases.

<PluginWorkflow />

While preparing the request, plugins are iterated over in the order they are passed to the client. Once a result
has been provided, its value is sent in reverse order through the list of plugins we've visited who can
modify the response.

## Create Your First Plugin

<AuthoringPluginsDive />

## Enter vs Exit Phases

It's important to keep in mind the direction that information is flowing in a given step.
As mentioned before, the request pipeline is broken up into 4 distinct phases. Of of them
(`start` and `network`) are known as "enter phases".

## Type Definitions

The best source of truth for the type definitions are exported from your `$houdini`
package. They've been summarized below for reference but this copy may be out of date.
If you find a discrepancy, please let us know on GitHub.

```typescript
type ClientPlugin = () => {
	start?: ClientPluginEnterPhase
	network?: ClientPluginEnterPhase
	afterNetwork?: ClientPluginExitPhase
	end?: ClientPluginExitPhase
	cleanup?(ctx: ClientPluginContext): void | Promise<void>
	throw?(ctx: ClientPluginContext, args: ClientPluginErrorHandlers): void | Promise<void>
}

type ClientPluginPhase<Handlers> = (
	ctx: ClientPluginContext,
	handlers: Handlers
) => void | Promise<void>

type ClientPluginEnterPhase = ClientPluginPhase<ClientPluginEnterHandlers>
type ClientPluginExitPhase = ClientPluginPhase<ClientPluginExitHandlers>

type ClientPluginEnterHandlers = {
	/* The initial value of the query */
	initialValue: QueryResult
	/** A reference to the houdini client */
	client: HoudiniClient
	/** Move onto the next step using the provided context.  */
	next(ctx: ClientPluginContext): void
	/** Terminate the current chain  */
	resolve(ctx: ClientPluginContext, data: QueryResult): void

	/** Update the stores state without resolving the promise */
	updateState(updater: (old: QueryResult) => QueryResult): void

	/** Return true if the variables have changed */
	variablesChanged: (ctx: ClientPluginContext) => boolean
	/** Returns the marshaled variables for the operation */
	marshalVariables: (ctx: ClientPluginContext) => Record<string, any>
}

/**
 * Exit handlers are the same as enter handles but don't need to
 * resolve with a specific value
 */
type ClientPluginExitHandlers = {
	/* The response value we're exiting with */
	value: QueryResult

	/* The initial value of the query */
	initialValue: QueryResult
	/** A reference to the houdini client */
	client: HoudiniClient
	/** Move onto the next step using the provided context.  */
	next(ctx: ClientPluginContext): void
	/** Terminate the current chain  */
	resolve: (ctx: ClientPluginContext, data?: QueryResult) => void

	/** Update the stores state without resolving the promise */
	updateState(updater: (old: QueryResult) => QueryResult): void

	/** Return true if the variables have changed */
	variablesChanged: (ctx: ClientPluginContext) => boolean
	/** Returns the marshaled variables for the operation */
	marshalVariables: (ctx: ClientPluginContext) => Record<string, any>
}

type ClientPluginContext = {
	config: ConfigFile
	artifact: DocumentArtifact
	policy?: CachePolicy
	fetch?: Fetch
	variables?: Record<string, any>
	metadata?: App.Metadata | null
	session?: App.Session | null
	fetchParams?: RequestInit
	cacheParams?: {
		layer?: Layer
		notifySubscribers?: SubscriptionSpec[]
		forceNotify?: boolean
		disableWrite?: boolean
		disableRead?: boolean
		applyUpdates?: boolean
	}
	stuff: Record<string, any>
}
```

### `start`
