---
layout: blank
---

<script>
    import { DeepDive, Warning } from '~/components'
    </script>

<DeepDive title="Get Started Creating Plugins">

## Your First Client Plugin

Let's start off simple and create a plugin to log something every time we send a query. If you don't have
a project to test in, you can always use [`final` branch](https://github.com/HoudiniGraphql/intro/tree/final) branch
of the PokeDex we made in the [Getting Started guide](/intro/welcome).

Once you have a project, we can define an empty plugin and pass it to your client:

```typescript:title=src/client.ts&typescriptToggle=true
import type { ClientPlugin } from '$houdini'

const sayHello: ClientPlugin = () => {
    return {}
}

export default new HoudiniClient({
    url: "...",
    plugins: [
        sayHello
    ]
})
```

Fundamentally a plugin is just a function that returns an object. That object can have a few different keys
to hook into different phases of the request. For our purposes, we just need to define an `start` function that
will run at the beginning of every request:

```typescript:title=src/client.ts&typescriptToggle=true
import type { ClientPlugin } from '$houdini'

const sayHello: ClientPlugin = () => {
    return {
        start(ctx, { next }) {
            // say hello
            console.log("Hello world!")

            // move onto the next step in the pipeline
            next(ctx)
        }
    }
}
```

And that's it! If you click around your app now, you should see our message logged every time a request is made.

<Warning title="Your plugin must call `next` or `resolve`">

While most of this example is self-explanatory, it's important to highlight that we had to call `next(ctx)`
in our plugin to indicate we were done. It's important to remember that these phases are asynchronous by nature.
If we never call `next` (or `resolve`) the pipeline would never terminate.

</Warning>

## Your Second Plugin

Now that you know what a plugin looks like, let's take it up a notch and create another one. This time, we're
going to create a plugin that retries a query if we encountered an error in the result.

It starts off looking very similar to the first example except this time we'll hook into the `end` step:

```typescript:title=src/client.ts&typescriptToggle=true
import type { ClientPlugin } from '$houdini'

const retry: ClientPlugin = () => {
    return {
        end(ctx, { resolve }) {
            // move onto the next step in the pipeline
            resolve(ctx)
        }
    }
}
```

`end` and `afterNetwork` are what we call "exit" phases. They trigger once a response has been generated by a plugin in the
first half of the pipeline. For most situations, an exit hook will use `resolve` where an enter phase would use `next`.

The important difference between `resolve` and `next` is the direction we are going. As we saw before, `next` is meant to push
the pipeline forward and send a request. `resolve` does the opposite and pushes an answer back to the caller/store. This means
that `end` and `afterNetwork` need to `resolve` at some point in order to get a result for our query. While this does sound kind of
complicated, having this distinction allows us to replay the request if we run into an error relatively easily:

```typescript:title=src/client.ts&typescriptToggle=true
import type { ClientPlugin } from '$houdini'

const retry: ClientPlugin = () => {
    return {
        end(ctx, { value, next, resolve }) {
            // if we ran into an error, start another request
            if (value.errors && value.errors.length > 0) {
                next(ctx)
                return
            }

            // there is no error so we can use the result
            resolve(ctx)
        }
    }
}
```

Keep in mind you would probably want to add more to this example in production so that you wouldn't be stuck in an loop that constantly errors
but hopefully you can piece together how you would do that.

## Plugins Are Data Sources

The store might receive multiple updates for a given set of inputs. For example, subscriptions and live queries
both push multiple documents into the cache and need to update the store value. Each payload should be pushed all
the way through the chain using the same `resolve` function. If the original request hasnâ€™t been resolved when a payload
reaches the end, the promise will resolve with that first value.

</DeepDive>
