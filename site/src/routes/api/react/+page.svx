---
title: React Framework
description: Documentation for Houdini's application framework
---

<script>
    import { Warning, DeepDive } from '~/components'
</script>

# React Framework

This page is currently the best place to go for documentation on Houdini's React framework.
Eventually this content will be merged in with the rest of this site but that will take time. If you
want to help with that effort, please reach out!

<Warning>

Houdini's React binding are still considered unstable and are subject to change with every patch update (the third number).
If you are building stuff with it, please check the changelog for any updates or pin to a specific version.

</Warning>

## What is Houdini?

Houdini is a web application framework built from the ground up for GraphQL. It provides everything you need to build
state-of-the-art apps. Not only does that include basic features like routing and SSR'd queries but also
advanced graphql patterns like paginated fragments and even optimizations for your application's bundle.

## Getting Started

The easiest way to start a new project is to run the following command and answer the prompts:

```bash
npm create houdini@latest
```

Once that's completed, navigate into the newly created directory, install the dependencies using your favorite package manager and then run `dev`:

```bash
cd <project name> && npm i && npm run dev
```

## Routing

At the core of a Houdini application is a filesystem-based located at `src/routes`. You will use it to encode your applications
visual skeleton as well as its data requirements. Routes in houdini are directory-based. That is to say:

- `src/routes` is the root route
- `src/routes/shows` corresponds to a route at `/shows`
- `src/routes/show/[id]` defines a route with a paramter, `id`, that matches a pattern such as `/show/1234`

Each route is defined by the presence of any number of magic files (all of which are conventionally prefixed with `+`).

### Page Views

Page views (defined by `+page.jsx`) are components that are unique to just that route and in many ways _define_ a route. For example, to
define a view at the root of your application you just need to define a component at `src/routes/+page.jsx`:

```jsx:title=src/routes/+page.tsx&typescriptToggle=true
export default () => {
    return <div> Hello Houdini! </div>
}
```

### Layout Views

Layout views (defined by `+layout.jsx`) are components that are shared across multiple routes and are designed to _wrap_
a page view. They are defined very similiarly to pages except they accept a `children` prop and "apply" to all child routes
and a sibling page if the appropriate `+page.jsx` is defined.

```jsx:title=src/routes/+layout.tsx&typescriptToggle=true
export default ({ children }) => {
    return (
        <>
            <NavBar />
            {children}
        </>
    )
}
```

### Links

Links between pages are defined using standard `<a>` tags.

### Route Parameters

Dynamic portions of a route can be labeled using square brackets. For example `src/routes/show/[id]/+page`
creates a page that matches `/shows/1` or `/show/abc`.

<DeepDive title="Rest Paramters">

If the length of a path segment is unknown, you can match multiple segments using the rest syntax. For example:
`src/routes/assets/[...filepath]`.
</DeepDive>

<DeepDive title="Optional Parameters">

Optional parameters are denoted with double brackets, ie `/[[lang]]/home/`.

<Warning>

Optional route parameter cannot follow a rest parameter ([...rest]/[[optional]]),
since parameters are matched 'greedily' and the optional parameter would always be unused.

</Warning>

</DeepDive>

## Loading data

Just like views are defined in page and layout variants, your applications queries
are defined in `+page.gql` and `+layout.gql` files. Queries must have a unique name:

```graphql:title=src/routes/shows/+page.gql
query ShowList {
    shows {
        title
    }
}
```

Just like their equivalent view component, layout queries are designed to "wrap" child routes and are
accessible by any child (or sibling) page or layout component.

To access the value of a query, your component just needs to accept a prop with the appropriate name.
Since this works off of very simple static analysis, your component props must be spread out from the
argument like so:

```jsx:title=src/routes/shows/+page.tsx&typescriptToggle=true
export default function ({ ShowList }) {
    return (
        <>
            {ShowList.map(show => (
                <div>
                    {show.title}
                </div>
            ))}
        </>
    )
}
```

An arrow function would have also worked as long as it had `{ ShowList }`


## Special Thanks

Special thanks to the whole Svelte team for being a constant source of inspiration. Houdini would not have been possible
without their tireless effort on SvelteKit and its documentation (which inspired a lot of the content in this site)
