---
title: Query
index: 1
description: Queries in Houdini
---

<script>
    import { HeaderWithMode, DeepDive, Highlight } from '~/components'
    import { Transformation } from '~/components'

  const forwardPaginationStoreBefore = `
query MyFriends {
  viewer {
    friends(first: 10) @paginate( name: "My_Friends") {
      edges {
        node {
          id
        }
      }
  }
}
`
	const forwardPaginationStoreAfter = `
type MyFriendsStore = QueryStore & {
  loadNextPage(
    pageCount?: number,
    after?: string | number
    houdiniContext?: HoudiniContext,
  ): Promise<void>,

  pageInfo: Readable<PageInfo>
}
`
	 const backwardsPaginationStoreBefore = `
query MyFriends {
  viewer {
    friends(last: 10) @paginate(name: "My_Friends") {
      edges {
        node {
          id
        }
      }
  }
}
`
	const backwardsPaginationStoreAfter = `
type MyFriendsStore = QueryStore & {
  loadPreviousPage(
    pageCount?: number,
    before?: string | number
    houdiniContext?: HoudiniContext,
  ): Promise<void>,

  pageInfo: Readable<PageInfo>
}
`
	 const offsetPaginationStoreBefore = `
query MyFriends {
  viewer {
    friends(limit: 10) @paginate(name: "My_Friends") {
      id
    }
  }
}
`
	const offsetPaginationStoreAfter = `
type MyFriendsStore = QueryStore & {
  loadNextPage(
    limit?: number,
    offset?: number
    houdiniContext?: HoudiniContext,
  ): Promise<void>,
}
`
</script>

<HeaderWithMode title="Query" />

Load data from the server and subscribe to any changes of fields we detect from mutations, subscriptions, and other queries.

```javascript
// src/routs/myRoute/+page.js

import { load_ViewerProfile } from '$houdini'

export async load(event) {
    return {
      ...await load_ViewerProfile({ event })
    }
}
```

```svelte
<!-- src/routs/myRoute/+page.js -->

<script>
  export let data

  // pull the store reference from the route props
  $: ({ ViewerProfile } = data)
</script>

{$ViewerProfile.data.viewerProfile.firstName}
```

### Store Value

A query store holds onto an object containing a variety of metadata
about the last query that was sent:

- `data`: holds the result of the query
- `errors`: a list of objects with a `message` field
- `isFetching`: a boolean that tracks the fetchingState (always false after a request)
- `partial`: a boolean indicating of the query has partial results. For more information see the [caching guide](/guides/caching-data#partial-data)
- `source`: one of `"network"` or `"cache"`. Indicates wether the result was read from the cache or the network
- `variables`: the variables used for the request

## Fetching Data

The quickest way to load data into a store is to call the `fetch` method when running in the browser:

```svelte
<script>
  import { browser } from '$app/env'
  import { GQL_MyQuery } from '$houdini'

  $: browser && GQL_MyQuery.fetch({ variables: { ... } })
</script>

{$GQL_MyQuery.data.value}
```

## SvelteKit

In SvelteKit, `fetch` needs to be called inside of your `load` function. In order to streamline this, houdini provides
a function for each of your stores that you can use to render your route on the server.

```javascript
import { load_MyQuery } from '$houdini'

export async function load(event) {
  return {
    ...await load_MyQuery({ event })
  }
}
```

In case you were wondering, the `load_` prefix is there so you can autocomplete your loads by just typing `load_<tab>`.
Anyway, with this in place, you can pull your route will recieve props for each of the stores that you have loaded:

```svelte
<script>
  export let data

  $: ({ MyQuery } = data)
</script>

{$MyQuery.data.value}
```

If your query has variables, you can pass them straight to the loader:

```javascript
import { load_MyQuery } from '$houdini'

export async function load(event) {
  return {
    ...await load_MyQuery({ event, variables: { ... } })
  }
}
```

<DeepDive title="Loading multiple stores simulatenously">

Be careful when loading multiple stores at once.

Each of your loads should be performed inside of an `await Promise.all` so you perform the queries in parallel.
This can get rather tedious so houdini provides a `loadAll` function you can use to simplify this process:


```javascript
import { loadAll, load_MyQuery, load_MyOtherQuery } from '$houdini'

export async function load(event) {
  return {
    ...await loadAll(
      load_MyQuery({ event }),
      load_MyOtherQuery({ event })
    )
  }
}
```

If you want to load the same store twice or customize the props that will get passed to your
route, you can pass any combination of single loaders and objects that map the result to a prop value:

```javascript
import { loadAll, load_MyQuery, load_MyOtherQuery } from '$houdini'

export async function load(event) {
  return {
    ...await loadAll(
      load_MyQuery({ event }),
      {
        propA: load_MyOtherQuery({ event, variables: { foo: "A" } }),
        propB: load_MyOtherQuery({ event, variables: { foo: "B" } }),
      }
    )
  }
}
```

The above example will provide 3 props to your route: `MyQuery` containing an instance of `MyQuery`, `propA` with an instance of `MyOtherQuery` with the variables `{foo: "A"}` loaded, and `propB` with an instance of `MyOtherQuery` with the variables `{foo: "B"}` loaded.

</DeepDive>

<DeepDive title="Blocking Navigation">

If we're not careful, the above code will cause every route transition to
block while the store waits for the server. While this sounds great
for server-side rendered views, this is usually not what we want for
client-side transitions. In order to accommodate this, awaiting
`fetch` or a loader does not actually wait for the promise to resolve when
the request happens on the browser. This means that if you want to
do something with the response, you have to pass `blocking: true`
which will make the `await` behave like normal:

```javascript
export async function load(event) {
	// blocking:true makes this await "real"
	const { data } = await MyStore.fetch({ event, blocking: true })

	// check the response of the query and redirect when appropriate
	if (!data.fieldName) {
		return {
			redirect: '/not-field-name'
		}
	}

	return {}
}
```

</DeepDive>

### Passing Metadata

Sometimes you need to do something very custom for a specific route. Maybe you need special headers or some other contextual information.
Whatever the case may be, you can pass a `metadata` parameter to fetch:

```svelte
<script context="module">
	import { browser } from '$app/env'
	import MyQueryStore from '$houdini/stores/MyQuery'
</script>

<script>
  export let variables

  $: browser && MyQueryStore.fetch({ variables, metadata: { ... } })
</script>
```

This value will get forwarded to the network function in your client definition, usually found in `src/client.js`:

```typescript
async function fetchQuery({ fetch, text, variables, session, metadata }) {
	// do anything with metadata inside of here
}

// Export the Houdini client
export default new HoudiniClient(fetchQuery)
```

## Endpoints

Using a query store inside of an endpoint looks very similar to the `load` function: just pass the event you
are handed in your route function:

```javascript
import { GQL_MyQuery } from '$houdini'

export async function get(event) {
	const { data } = await GQL_MyQuery.fetch({ event })

	return {
		body: {
			data
		}
	}
}
```

## Paginated Queries

If the query contains the pagination directive then the generated store will have extra fields/methods
according to the pagination strategy and direction. For more information about pagination in general, check
out [this guide](/guides/pagination).

### Forward cursor pagination

If the decorated field implements cursor-based pagination and provides a `first` argument, the query store will be
generated with an extra method that loads more data and a field pointing to a store with the current `pageInfo`
object. This extra field can be used to track if there are more pages to load:

<Transformation>
	<Highlight slot="from" code={forwardPaginationStoreBefore} language="graphql" />
	<Highlight slot="to" code={forwardPaginationStoreAfter} language="typescript"/>
</Transformation>

### Backwards cursor pagination

If the decorated field implements cursor-based pagination and provides a `last` argument, the query store will be
generated with an extra method that loads more data and a field pointing to a store with the current `pageInfo`
object. This extra field can be used to track if there are more pages to load:

<Transformation>
	<Highlight slot="from" code={backwardsPaginationStoreBefore} language="graphql" />
	<Highlight slot="to" code={backwardsPaginationStoreAfter} language="typescript"/>
</Transformation>

### Offset/limit Pagination

If the decorated field implements offset/limit pagination and provides a `limit` argument, the query store will be generated with an extra methods that lets it load more pages after the one the current one:

<Transformation>
	<Highlight slot="from" code={offsetPaginationStoreBefore} language="graphql" />
	<Highlight slot="to" code={offsetPaginationStoreAfter} language="typescript"/>
</Transformation>
