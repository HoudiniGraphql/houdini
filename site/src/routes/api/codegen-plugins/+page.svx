---
title: Codegen Plugins
description: An overview of Houdini's Codegen Plugins
---

<script>
    import { ExtractDiagram, ValidateDiagram, SetupDiagram, GenerateDiagram } from '~/routes/_diagrams'
</script>

# Codegen Plugins

Codegen plugins allow you to add additional behavior to Houdini's static processing. This includes
integrating into the core code generation pipeline as well as transforming files (usually to take advantage
of what was generated).

> This is an advanced topic and requires a deep understanding of Houdini. Please make
> sure you've at least seen the example at the bottom of the
> [Architecture Guide](/guides/architecture).
> If something isn't clicking or if you have any questions, please
> [join us on discord](https://discord.gg/Gd8vfvxpsD) and ask!

For information on adding a plugin to your project, checkout the
[Config reference](/api/config#adding-plugins).

## Defining a Plugin

A codegen plugin is defined as an asynchronous function that returns
an object with a fixed set of keys, defining the "hooks" that you want
to use:

```javascript:title=src/plugins/myPlugins.js
/** @type { import("houdini").Plugin }*/
const generateSomething = async () =>  {
    return {
        generate({ documents }) {
            // generate something for every document in the project
        }
    }
}
```

For a summary of the hooks you can use, check out the [Generation Pipeline](#generation-pipeline)
section below.

### Accepting configuration

Most of time, your plugin will need to accept configuration from the user. To support this, Houdini
users are asked to pass objects in their config file which are then passed to your function:

```javascript:title=houdini.config.js
export default {
    plugins: {
        './src/plugins/myPlugins.js': {
            aValue: 'myValue',
        }
    }
}
```

```javascript:title=src/plugins/myPlugins.js
/** @type { import("houdini").Plugin }*/
const generateSomething = async ({ aValue }) =>  {
    return {
        generate({ documents }) {
            // do something with aValue
        }
    }
}
```

Remember, local plugins have to be importable by Node so they must be written in JavaScript.

#### Typesafe Config Values

If you use typescript, you probably want type definitions for your configuration
values. The best way to set that up is by
extending the `HoudiniPluginConfig` in the `houdini` module to map your plugin's
name with your custom config type. This will merge your
definition with the one Houdini uses internally:

```typescript:title=my-custom-plugin/src/index.ts
declare module 'houdini' {
	interface HoudiniPluginConfig {
		'my-custom-plugin': CustomPluginConfig
	}
}

export type CustomPluginConfig = {
    aValue: string
}
```

With that defined, a user can now include add a reference to your plugin's declarations and rely on
your custom type in their config file:

```javascript:title=houdini.config.js
/// <references types="my-custom-plugin">

/** @type { import('houdini').ConfigFile } */
export default {
    plugins: {
        'my-custom-plugin': {
            aValue: 'myValue',
        }
    }
}
```

## Publishing a Plugin

## Plugin Setup

Every pipeline begins with a common set of hooks that allow you to setup
and configure the system. This can include loading environment variables or
updating any configuration values.

<SetupDiagram style="max-width: 250px; margin: 0 auto;" />

#### `config`

- Type: `(old: ConfigFile) => ConfigFile`
- Can return a `Promise` as well
- Plugins might overwrite each other

Used to modify any values that the user passed to their config files.
Configuration values that you return will be deeply merged with the previous
value. If you just want to look at the config values, we recommend using
[after_load](#after_load) which will have the final set of values after all `config`
hooks have run.

#### `env`

- Type: `({ env: any; config: Config }) => Promise<Record<string, string>>`
- Plugins might overwrite each other

Adds environment variables to houdini's pipeline (ie, for schema polling headers, url, etc.).
Plugins are executed in the order they are defined so they can overwrite each other.


#### `after_load`

- Type: `(config: Config) => Promise<void> | void`

Invoked after all plugins have loaded and modified config values. This is the hook to use
if you want to perform logic based on config values.

## Generation Pipeline

The code generation pipeline is broken up into 3 parts:

- [Extract and Parse](#extract-and-parse) finds and parses all of the GraphQL documents in your application
- [Validate and Transform](#validate-and-transform) verifies your application's documents and
  transforms them to fit the needs of your plugin.
- [Generate](#generate-pipeline) creates the various artifacts that your application needs.

### Extract and Parse

These hooks are responsibile for generating a list of filepaths and finding the GraphQL
documents inside.

<ExtractDiagram style="max-width: 600px; margin: 0 auto;"/>

#### `extensions`

- Type: `string[]`
- Plugin values are concattenated together

Add extensions to the list that houdini uses to find valid source files.

#### `include`

- Type: `(config: Config, filepath: string) => boolean | null | undefined`
- If any plugin includes the value, the filepath is excluded

A filter for wether a file should be included in processing. This hook is useful
if you generate imports that do not match your users configure `include` value.
Return `true` to include the file.

#### `exclude`

- Type: `(config: Config, filepath: string) => boolean | null | undefined`
- If any plugin excludes the value, the filepath is excluded

A filter for wether a file should be included in processing. This hook is useful
if you generate imports that do not match your users configure `include` value.
Return `false` to include the file.

#### `extract_documents`

- Type: `(config: Config, path: string, content: string) => string[] | null`
- Can return a `Promise` as well
- Plugin values are concattenated together

Teaches the pipeline how to extract graphql documents out of your application source code
given its filepath and the file contents. You can return `null` or an empty string to indicate
that you didn't find any graphql documents. This step is responsible for actually parsing your
source code and extracting the string values of the `graphql` function.


#### `schema`

- Type: `({ config: Config, path: string, content: string }) => string`

Can be used to add custom definitions to your project's schema. Definitions (like directives) added
here are automatically removed from the document before they are sent to the server. It is sometimes
useful to add things that can be used in connection with [artifact_data](#artitfact_data)
or [artifact_selection](#artfiact_selection) to embed data in the artifact.

Currently, this hook can only add directives, scalars, or enums to the schema.

### Transform and Validate

These hooks are responsible for transforming and validating the documents in your application. If you want
to add new definitions, you can add new documents to provided list.

<ValidateDiagram style="max-width: 600px; margin: 0 auto;"/>

#### `transform_before_validate`

- Type: `({config: Config documents: CollectedGraphQLDocument[]}) => void`
- Can also return a Promise

A hook to transform documents before they has been validated. This can be useful if you are adding a layer
that translates into a Houdini feature.

#### `validate`

- Type: `({config: Config documents: CollectedGraphQLDocument[]}) => void`
- Can also return a Promise

A hook to ensure that assumptions made by the rest of the tasks are true. For example,
the [uniqueNames](https://github.com/HoudiniGraphql/houdini/blob/main/packages/houdini/src/codegen/validators/uniqueNames.ts)
validator makes sure that every document has a unique name so that the preprocessor can
reliably import the correct artifact.

#### `transform_after_validate`

- Type: `({config: Config documents: CollectedGraphQLDocument[]}) => void`
- Can also return a Promise

A hook to transform the documents after they have been validated. This is useful if you are building a feature
that needs to add extra selections or documents to the list.

### Generate Pipeline

This Pipeline is responsible for generating all of the files for your application. This includes hooks to
modify the query artifact (a static respresentation of the document), hooks to customize the core runtime
provided by houdini, as well as hooks to generate your own files and runtimes for your plugin.

<GenerateDiagram style="max-width: 600px; margin: 0 auto;"/>

#### `transform_before_generate`

- Type: `({config: Config documents: CollectedGraphQLDocument[]}) => void`
- Can also return a Promise

A hook to transform the documents just before static assets are generated.

#### `artifact_data`
- Type: (config: Config, doc: CollectedGraphQLDocument) => Record<string, any>

A hook to embed metadata at the root of the artifact. You should use this to encode document-level
data at build time so you don't have to analyze the document at runtime (in a client plugin, for example).

#### `artifact_selection`

Not Yet Implemented

#### `artifact_end`

Not Yet Implemented

#### `hash`

Not Yet Implemented

#### `index_file`
- Type: `(args: IndexFileArgs) => string`

```typescript
type IndexFileArgs = {
	config: Config
	content: string
	export_default_as(args: { module: string; as: string }): string
	export_star_from(args: { module: string }): string
	plugin_root: string
	typedef: boolean
	documents: CollectedGraphQLDocument[]
}
```

A hook to modify the root `index.js` and `index.d.ts` files in the generated runtime. If you want to
add any exports, make sure to use the `export_default_as` and `export_star_from` utilities which will
make sure your type definitions are up to date.

#### `graphql_tag_return`

- Type: `({
		config,
		document,
		ensure_import
	}) => string | undefined`
- The first value provided by a plugin is used

A hook to customize the return type of the graphql function. If you need to add an import to the file
in order to resolve the import, you can use the `ensure_import` utility:

```javascript:title=myPlugins.js
export default {
    graphql_tag_return({ config, ensure_import }) {
        // TODO
    }
}
```

#### `generate`

#### `include_runtime`

#### `transform_runtime`

## Transform Hooks

#### `transform_file`

## Definitions

This section contains definitions for terms used throughout this document

### Plugin Order
